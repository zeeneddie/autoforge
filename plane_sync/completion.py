"""Sprint completion: DoD verification, retrospective, git tagging."""

from __future__ import annotations

import logging
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path

from .client import PlaneApiClient, PlaneApiError
from .models import SprintCompletionResult

logger = logging.getLogger(__name__)

# Lazy imports to avoid circular dependencies
_create_database = None
_Feature = None


def _get_db_classes():
    global _create_database, _Feature
    if _create_database is None:
        root = Path(__file__).parent.parent
        if str(root) not in sys.path:
            sys.path.insert(0, str(root))
        from api.database import Feature, create_database
        _create_database = create_database
        _Feature = Feature
    return _create_database, _Feature


def _get_db_session(project_dir: Path):
    from contextlib import contextmanager

    @contextmanager
    def _session():
        create_database, _ = _get_db_classes()
        _, SessionLocal = create_database(project_dir)
        session = SessionLocal()
        try:
            yield session
        except Exception:
            session.rollback()
            raise
        finally:
            session.close()

    return _session()


def _get_change_log(project_dir: Path) -> str:
    """Generate a change log from git log since the last tag."""
    try:
        # Find the last tag
        last_tag = subprocess.run(
            ["git", "describe", "--tags", "--abbrev=0"],
            cwd=project_dir,
            capture_output=True,
            text=True,
            timeout=10,
        )

        if last_tag.returncode == 0 and last_tag.stdout.strip():
            ref_range = f"{last_tag.stdout.strip()}..HEAD"
        else:
            # No tags yet â€” show all commits (limit to 50)
            ref_range = "HEAD"

        result = subprocess.run(
            ["git", "log", "--oneline", "-50", ref_range],
            cwd=project_dir,
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass
    return ""


def _build_retrospective_html(
    features: list[dict],
    change_log: str,
    cycle_name: str,
) -> str:
    """Build an HTML retrospective summary for posting to Plane."""
    passing = sum(1 for f in features if f["passes"])
    total = len(features)

    lines = [
        f"<h3>Sprint Retrospective: {cycle_name}</h3>",
        f"<p><strong>Pass rate:</strong> {passing}/{total} features</p>",
        "<h4>Features</h4>",
        "<ul>",
    ]
    for f in features:
        status = "PASS" if f["passes"] else "FAIL"
        lines.append(f'<li>[{status}] {f["name"]}</li>')
    lines.append("</ul>")

    if change_log:
        lines.append("<h4>Change Log</h4>")
        lines.append("<pre>")
        lines.append(change_log)
        lines.append("</pre>")

    lines.append(f"<p><em>Generated by AutoForge at {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}</em></p>")
    return "\n".join(lines)


def _build_feature_comment_html(feature_name: str, passes: bool, change_log: str) -> str:
    """Build an HTML comment for an individual work item."""
    status = "PASSED" if passes else "FAILED"
    lines = [
        f"<p><strong>AutoForge Sprint Result: {status}</strong></p>",
        f"<p>Feature: {feature_name}</p>",
    ]
    if change_log:
        lines.append("<details><summary>Change log</summary>")
        lines.append(f"<pre>{change_log}</pre>")
        lines.append("</details>")
    return "\n".join(lines)


def complete_sprint(
    client: PlaneApiClient,
    project_dir: Path,
    cycle_id: str,
) -> SprintCompletionResult:
    """Complete a sprint: verify DoD, post retrospective, create git tag.

    Flow:
    1. Verify all Plane-linked features are passing
    2. Generate change log from git history
    3. Post completion comment on each work item
    4. Update cycle description with retrospective
    5. Create git tag

    Args:
        client: Authenticated PlaneApiClient.
        project_dir: Path to the AutoForge project directory.
        cycle_id: Plane cycle UUID.

    Returns:
        SprintCompletionResult with details.
    """
    _, Feature = _get_db_classes()

    # 1. Verify DoD
    with _get_db_session(project_dir) as session:
        linked_features = session.query(Feature).filter(
            Feature.plane_work_item_id.isnot(None)
        ).all()

        if not linked_features:
            return SprintCompletionResult(
                success=False,
                error="No Plane-linked features found",
            )

        feature_data = []
        for f in linked_features:
            feature_data.append({
                "name": f.name,
                "passes": bool(f.passes),
                "plane_work_item_id": f.plane_work_item_id,
            })

    passing = sum(1 for f in feature_data if f["passes"])
    failed = len(feature_data) - passing

    if failed > 0:
        return SprintCompletionResult(
            success=False,
            features_completed=passing,
            features_failed=failed,
            error=f"{failed} feature(s) not passing. All features must pass to complete the sprint.",
        )

    # 2. Generate change log
    change_log = _get_change_log(project_dir)

    # 3. Get cycle info
    try:
        cycle = client.get_cycle(cycle_id)
        cycle_name = cycle.name
    except PlaneApiError:
        cycle_name = cycle_id

    # 4. Post comments on each work item
    for f in feature_data:
        try:
            comment_html = _build_feature_comment_html(
                f["name"], f["passes"], change_log
            )
            client.create_issue_comment(f["plane_work_item_id"], comment_html)
        except PlaneApiError as e:
            logger.warning(
                "Failed to post comment on work item %s: %s",
                f["plane_work_item_id"], e,
            )

    # 5. Update cycle description with retrospective
    retro_html = _build_retrospective_html(feature_data, change_log, cycle_name)
    try:
        # Append retrospective to existing description
        existing_desc = cycle.description or ""
        separator = "\n<hr/>\n" if existing_desc else ""
        client.update_cycle(
            cycle_id,
            {"description": existing_desc + separator + retro_html},
        )
    except PlaneApiError as e:
        logger.warning("Failed to update cycle description: %s", e)

    # 6. Create git tag
    tag_name = f"sprint/{cycle_name.lower().replace(' ', '-')}"
    tag_message = f"Sprint complete: {cycle_name} ({passing}/{len(feature_data)} features passing)"
    git_tag = None

    try:
        result = subprocess.run(
            ["git", "tag", "-a", tag_name, "-m", tag_message],
            cwd=project_dir,
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0:
            git_tag = tag_name
            logger.info("Created git tag: %s", tag_name)
        else:
            logger.warning("Git tag failed: %s", result.stderr.strip())
    except (subprocess.TimeoutExpired, FileNotFoundError) as e:
        logger.warning("Git tag failed: %s", e)

    # 7. Store completion in registry
    try:
        root = Path(__file__).parent.parent
        if str(root) not in sys.path:
            sys.path.insert(0, str(root))
        from registry import set_setting
        set_setting(f"plane_sprint_completed_{cycle_id}", "true")
    except Exception as e:
        logger.warning("Failed to store completion flag: %s", e)

    return SprintCompletionResult(
        success=True,
        features_completed=passing,
        features_failed=failed,
        git_tag=git_tag,
        change_log=change_log,
    )
